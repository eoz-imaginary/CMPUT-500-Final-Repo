[["Divides.v", "Divides.", " \nLemma div_ref : forall a : nat, divides a a.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a : nat, divides a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a : nat, divides a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_dec' :\n forall x y : nat,\n {(exists q : _, is_div x y q 0)} + {~ (exists q : _, is_div x y q 0)}.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x y : nat,\nsumbool (ex (fun q : nat => is_div x y q O))\n  (not (ex (fun q : nat => is_div x y q O)))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x y : nat,\nsumbool (ex (fun q : nat => is_div x y q O))\n  (not (ex (fun q : nat => is_div x y q O)))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_div :\n forall x y : nat, 0 < y -> divides y x -> exists q : _, is_div x y q 0.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (x y : nat) (_ : lt O y) (_ : divides y x),\nex (fun q : nat => is_div x y q O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (x y : nat) (_ : lt O y) (_ : divides y x),\nex (fun q : nat => is_div x y q O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct H0.", "context_before": {"fg_goals": [{"hypotheses": ["H0 : divides y x", "H : lt O y", "x,y : nat"], "goal": "ex (fun q : nat => is_div x y q O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "subst.", "context_before": {"fg_goals": [{"hypotheses": ["H0 : eq b (Init.Nat.mul q a)", "b,q : nat", "H : lt O a", "a : nat"], "goal": "ex (fun q : nat => is_div b a q O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "exists q.", "context_before": {"fg_goals": [{"hypotheses": ["q : nat", "H : lt O a", "a : nat"], "goal": "ex (fun q0 : nat => is_div (Init.Nat.mul q a) a q0 O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["q : nat", "H : lt O a", "a : nat"], "goal": "is_div (Init.Nat.mul q a) a q O"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["q : nat", "H : lt O a", "a : nat"], "goal": "lt O a"}], "bg_goals": [{"hypotheses": ["q : nat", "H : lt O a", "a : nat"], "goal": "eq (Init.Nat.mul q a) (Init.Nat.add (Init.Nat.mul q a) O)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["q : nat", "H : lt O a", "a : nat"], "goal": "eq (Init.Nat.mul q a) (Init.Nat.add (Init.Nat.mul q a) O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma div_divides :\n forall x y : nat, (exists q : _, is_div x y q 0) -> divides y x.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (x y : nat) (_ : ex (fun q : nat => is_div x y q O)),\ndivides y x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (x y : nat) (_ : ex (fun q : nat => is_div x y q O)),\ndivides y x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma all_divides_O : forall n : nat, divides n 0.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall n : nat, divides n O"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall n : nat, divides n O"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma SO_divides_all : forall n : nat, divides 1 n.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall n : nat, divides (S O) n"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall n : nat, divides (S O) n"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_dec : forall x y : nat, {divides x y} + {~ divides x y}.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x y : nat, sumbool (divides x y) (not (divides x y))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x y : nat, sumbool (divides x y) (not (divides x y))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem divides_le : forall a b : nat, b <> 0 -> divides a b -> a <= b.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : not (eq b O)) (_ : divides a b), le a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : not (eq b O)) (_ : divides a b), le a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct H0.", "context_before": {"fg_goals": [{"hypotheses": ["H0 : divides a b", "H : not (eq b O)", "a,b : nat"], "goal": "le a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "subst b.", "context_before": {"fg_goals": [{"hypotheses": ["H0 : eq b (Init.Nat.mul q a)", "a,q : nat", "H : not (eq b O)", "b : nat"], "goal": "le a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct q.", "context_before": {"fg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul q a) O)", "a,q : nat"], "goal": "le a (Init.Nat.mul q a)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "simpl.", "context_before": {"fg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul O a) O)", "a : nat"], "goal": "le a (Init.Nat.mul O a)"}], "bg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul (S q) a) O)", "a,q : nat"], "goal": "le a (Init.Nat.mul (S q) a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "tauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul O a) O)", "a : nat"], "goal": "le a O"}], "bg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul (S q) a) O)", "a,q : nat"], "goal": "le a (Init.Nat.mul (S q) a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "simpl.", "context_before": {"fg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul (S q) a) O)", "a,q : nat"], "goal": "le a (Init.Nat.mul (S q) a)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intuition.", "context_before": {"fg_goals": [{"hypotheses": ["H : not (eq (Init.Nat.mul (S q) a) O)", "a,q : nat"], "goal": "le a (Init.Nat.add a (Init.Nat.mul q a))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_plus1 :\n forall a b c : nat, divides a b -> divides a c -> divides a (b + c).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : divides a b) (_ : divides a c),\ndivides a (Init.Nat.add b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : divides a b) (_ : divides a c),\ndivides a (Init.Nat.add b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma not_prime_O : ~ prime 0.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "not (prime O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "not (prime O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma not_prime_1 : ~ prime 1.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "not (prime (S O))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "generalize not_prime_O.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "not (prime (S O))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "generalize not_prime_O.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall _ : not (prime O), not (prime (S O))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "compute.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (_ : not (prime O)) (_ : not (prime O)), not (prime (S O))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (_ : forall _ : prime O, False) (_ : forall _ : prime O, False)\n  (_ : prime (S O)), False"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "inversion H1.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : prime (S O)", "H,H0 : forall _ : prime O, False"], "goal": "False"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H4 : eq a (S O)", "H3 : forall (b : nat) (_ : divides b (S O)) (_ : not (eq b (S O))),\neq (S O) b", "H2 : not (eq (S O) (S O))", "a : nat", "H1 : prime (S O)", "H,H0 : forall _ : prime O, False"], "goal": "False"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma lt_prime : forall p : nat, prime p -> 1 < p.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p : nat) (_ : prime p), lt (S O) p"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p : nat) (_ : prime p), lt (S O) p"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_plus2 :\n forall a b c : nat, divides a b -> divides a (b + c) -> divides a c.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : divides a b)\n  (_ : divides a (Init.Nat.add b c)), divides a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : divides a b)\n  (_ : divides a (Init.Nat.add b c)), divides a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma is_gcd_ref : forall x : nat, is_gcd x x x.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, is_gcd x x x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, is_gcd x x x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct x.", "context_before": {"fg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd x x x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "is_gcd O O O"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd (S x) (S x) (S x)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "divides O O"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd (S x) (S x) (S x)"}, {"hypotheses": [], "goal": "divides O O"}, {"hypotheses": [], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d O"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "divides O O"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd (S x) (S x) (S x)"}, {"hypotheses": [], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d O"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d O"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd (S x) (S x) (S x)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply all_divides_O.", "context_before": {"fg_goals": [{"hypotheses": ["H,H0 : divides d O", "d : nat"], "goal": "divides d O"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd (S x) (S x) (S x)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "split.", "context_before": {"fg_goals": [{"hypotheses": ["x : nat"], "goal": "is_gcd (S x) (S x) (S x)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["x : nat"], "goal": "divides (S x) (S x)"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "divides (S x) (S x)"}, {"hypotheses": ["x : nat"], "goal": "forall (d : nat) (_ : divides d (S x)) (_ : divides d (S x)),\ndivides d (S x)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["x : nat"], "goal": "divides (S x) (S x)"}], "bg_goals": [{"hypotheses": ["x : nat"], "goal": "forall (d : nat) (_ : divides d (S x)) (_ : divides d (S x)),\ndivides d (S x)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["x : nat"], "goal": "forall (d : nat) (_ : divides d (S x)) (_ : divides d (S x)),\ndivides d (S x)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct d.", "context_before": {"fg_goals": [{"hypotheses": ["H,H0 : divides d (S x)", "x,d : nat"], "goal": "divides d (S x)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H,H0 : divides O (S x)", "x : nat"], "goal": "divides O (S x)"}], "bg_goals": [{"hypotheses": ["H,H0 : divides (S d) (S x)", "x,d : nat"], "goal": "divides (S d) (S x)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H,H0 : divides (S d) (S x)", "x,d : nat"], "goal": "divides (S d) (S x)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_antisym : forall a b : nat, divides a b -> divides b a -> a = b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : divides a b) (_ : divides b a), eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : divides a b) (_ : divides b a), eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma is_gcd_sym : forall a b c : nat, is_gcd a b c -> is_gcd b a c.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : is_gcd a b c), is_gcd b a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "induction a.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : is_gcd a b c), is_gcd b a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct b.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (b c : nat) (_ : is_gcd O b c), is_gcd b O c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (c : nat) (_ : is_gcd O O c), is_gcd O O c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}, {"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "inversion H.", "context_before": {"fg_goals": [{"hypotheses": ["H : is_gcd O O c", "c : nat"], "goal": "is_gcd O O c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}, {"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "is_gcd O O c"}], "bg_goals": [{"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}, {"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "divides c O"}], "bg_goals": [{"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}, {"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}, {"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "divides c O"}, {"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "divides c O"}], "bg_goals": [{"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}, {"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}, {"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c", "H0,H1 : divides c O", "H : is_gcd O O c", "c : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d c"}], "bg_goals": [{"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}, {"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["b : nat"], "goal": "forall (c : nat) (_ : is_gcd O (S b) c), is_gcd (S b) O c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct H.", "context_before": {"fg_goals": [{"hypotheses": ["H : is_gcd O (S b) c", "b,c : nat"], "goal": "is_gcd (S b) O c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "is_gcd (S b) O c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "divides c (S b)"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}, {"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "divides c O"}, {"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "forall (d : nat) (_ : divides d (S b)) (_ : divides d O), divides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "divides c O"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}, {"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "forall (d : nat) (_ : divides d (S b)) (_ : divides d O), divides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d O) (_ : divides d (S b)), divides d c", "H0 : divides c (S b)", "H : divides c O", "b,c : nat"], "goal": "forall (d : nat) (_ : divides d (S b)) (_ : divides d O), divides d c"}], "bg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct b.", "context_before": {"fg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (b c : nat) (_ : is_gcd (S a) b c), is_gcd b (S a) c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) O c), is_gcd O (S a) c"}], "bg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "inversion H.", "context_before": {"fg_goals": [{"hypotheses": ["H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "is_gcd O (S a) c"}], "bg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "is_gcd O (S a) c"}], "bg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "divides c O"}], "bg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}, {"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "divides c (S a)"}, {"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d (S a)), divides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "divides c (S a)"}], "bg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}, {"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d (S a)), divides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : forall (d : nat) (_ : divides d (S a)) (_ : divides d O), divides d c", "H1 : divides c O", "H0 : divides c (S a)", "H : is_gcd (S a) O c", "c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d (S a)), divides d c"}], "bg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["b : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (c : nat) (_ : is_gcd (S a) (S b) c), is_gcd (S b) (S a) c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct H.", "context_before": {"fg_goals": [{"hypotheses": ["H : is_gcd (S a) (S b) c", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "is_gcd (S b) (S a) c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "is_gcd (S b) (S a) c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "divides c (S b)"}], "bg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "divides c (S a)"}, {"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (d : nat) (_ : divides d (S b)) (_ : divides d (S a)),\ndivides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "divides c (S a)"}], "bg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (d : nat) (_ : divides d (S b)) (_ : divides d (S a)),\ndivides d c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H1 : forall (d : nat) (_ : divides d (S a)) (_ : divides d (S b)),\ndivides d c", "H0 : divides c (S b)", "H : divides c (S a)", "b,c : nat", "IHa : forall (b c : nat) (_ : is_gcd a b c), is_gcd b a c", "a : nat"], "goal": "forall (d : nat) (_ : divides d (S b)) (_ : divides d (S a)),\ndivides d c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma is_gcd_O' : forall a r : nat, is_gcd a 0 r -> a = r.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a r : nat) (_ : is_gcd a O r), eq a r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a r : nat) (_ : is_gcd a O r), eq a r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma is_gcd_Ol : forall a : nat, is_gcd a 0 a.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a : nat, is_gcd a O a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a : nat, is_gcd a O a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct a.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd a O a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "is_gcd O O O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd (S a) O (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "divides O O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd (S a) O (S a)"}, {"hypotheses": [], "goal": "divides O O"}, {"hypotheses": [], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d O"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "divides O O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd (S a) O (S a)"}, {"hypotheses": [], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d O"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d O), divides d O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd (S a) O (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply all_divides_O.", "context_before": {"fg_goals": [{"hypotheses": ["H,H0 : divides d O", "d : nat"], "goal": "divides d O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd (S a) O (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd (S a) O (S a)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "divides (S a) (S a)"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "divides (S a) O"}, {"hypotheses": ["a : nat"], "goal": "forall (d : nat) (_ : divides d (S a)) (_ : divides d O),\ndivides d (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "divides (S a) O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "forall (d : nat) (_ : divides d (S a)) (_ : divides d O),\ndivides d (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "forall (d : nat) (_ : divides d (S a)) (_ : divides d O),\ndivides d (S a)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma is_gcd_Or : forall a : nat, is_gcd 0 a a.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a : nat, is_gcd O a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a : nat, is_gcd O a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct a.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd O a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply is_gcd_Ol.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "is_gcd O O O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd O (S a) (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "is_gcd O (S a) (S a)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "divides (S a) O"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "divides (S a) (S a)"}, {"hypotheses": ["a : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d (S a)),\ndivides d (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "divides (S a) (S a)"}], "bg_goals": [{"hypotheses": ["a : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d (S a)),\ndivides d (S a)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["a : nat"], "goal": "forall (d : nat) (_ : divides d O) (_ : divides d (S a)),\ndivides d (S a)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_rec :\n forall P : nat -> nat -> Set,\n (forall x : nat, P 0 x) ->\n (forall x : nat, P x 0) ->\n (forall a b : nat, P a b -> P a (b + a)) ->\n (forall a b : nat, P a b -> P (a + b) b) -> forall a b : nat, P a b.\n"], {"status": "FAILURE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (P : forall (_ : nat) (_ : nat), Set)\n  (_ : forall x : nat, P O x) (_ : forall x : nat, P x O)\n  (_ : forall (a b : nat) (_ : P a b), P a (Init.Nat.add b a))\n  (_ : forall (a b : nat) (_ : P a b), P (Init.Nat.add a b) b)\n  (a b : nat), P a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (P : forall (_ : nat) (_ : nat), Set)\n  (_ : forall x : nat, P O x) (_ : forall x : nat, P x O)\n  (_ : forall (a b : nat) (_ : P a b), P a (Init.Nat.add b a))\n  (_ : forall (a b : nat) (_ : P a b), P (Init.Nat.add a b) b)\n  (a b : nat), P a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_ind :\n forall P : nat -> nat -> Prop,\n (forall x : nat, P 0 x) ->\n (forall x : nat, P x 0) ->\n (forall a b : nat, P a b -> P a (b + a)) ->\n (forall a b : nat, P a b -> P (a + b) b) -> forall a b : nat, P a b.\n"], {"status": "FAILURE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (P : forall (_ : nat) (_ : nat), Prop)\n  (_ : forall x : nat, P O x) (_ : forall x : nat, P x O)\n  (_ : forall (a b : nat) (_ : P a b), P a (Init.Nat.add b a))\n  (_ : forall (a b : nat) (_ : P a b), P (Init.Nat.add a b) b)\n  (a b : nat), P a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (P : forall (_ : nat) (_ : nat), Prop)\n  (_ : forall x : nat, P O x) (_ : forall x : nat, P x O)\n  (_ : forall (a b : nat) (_ : P a b), P a (Init.Nat.add b a))\n  (_ : forall (a b : nat) (_ : P a b), P (Init.Nat.add a b) b)\n  (a b : nat), P a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma not_lt_div : forall a b : nat, 0 < b -> b < a -> ~ divides a b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : lt O b) (_ : lt b a), not (divides a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : lt O b) (_ : lt b a), not (divides a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma prime_gcd : forall p n : nat, prime p -> ~ divides p n -> is_gcd n p 1.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p n : nat) (_ : prime p) (_ : not (divides p n)),\nis_gcd n p (S O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p n : nat) (_ : prime p) (_ : not (divides p n)),\nis_gcd n p (S O)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem gcd_inv_Or : forall a b : nat, gcd_spec a 0 b -> a = b.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : gcd_spec a O b), eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : gcd_spec a O b), eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eapply gcd_inv_Or_aux.", "context_before": {"fg_goals": [{"hypotheses": ["H : gcd_spec a O b", "a,b : nat"], "goal": "eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : gcd_spec a O b", "a,b : nat"], "goal": "gcd_spec a ?b b"}], "bg_goals": [{"hypotheses": ["H : gcd_spec a O b", "a,b : nat"], "goal": "eq ?b O"}], "shelved_goals": [{"hypotheses": ["H : gcd_spec a O b", "a,b : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : gcd_spec a O b", "a,b : nat"], "goal": "eq O O"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma is_gcd_unic :\n forall a b c d : nat, is_gcd a b c -> is_gcd a b d -> c = d.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c d : nat) (_ : is_gcd a b c) (_ : is_gcd a b d), eq c d"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c d : nat) (_ : is_gcd a b c) (_ : is_gcd a b d), eq c d"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_ex : forall a b : nat, {r : nat | gcd_spec a b r}.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, sig (fun r : nat => gcd_spec a b r)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, sig (fun r : nat => gcd_spec a b r)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem gcd_inv_Or_aux : forall a b c : nat, gcd_spec a b c -> b = 0 -> a = c.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : gcd_spec a b c) (_ : eq b O), eq a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : gcd_spec a b c) (_ : eq b O), eq a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_correct : forall a b : nat, gcd_spec a b (gcd a b).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, gcd_spec a b (gcd a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, gcd_spec a b (gcd a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem gcd_inv_Ol : forall a b : nat, gcd_spec 0 a b -> a = b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : gcd_spec O a b), eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b : nat) (_ : gcd_spec O a b), eq a b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem gcd_inv_Ol_aux : forall a b c : nat, gcd_spec a b c -> a = 0 -> b = c.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : gcd_spec a b c) (_ : eq a O), eq b c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c : nat) (_ : gcd_spec a b c) (_ : eq a O), eq b c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_def0l : forall x : nat, gcd 0 x = x.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, eq (gcd O x) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, eq (gcd O x) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_def0r : forall x : nat, gcd x 0 = x.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, eq (gcd x O) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, eq (gcd x O) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_correct2 : forall a b r : nat, gcd_spec a b r -> gcd a b = r.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b r : nat) (_ : gcd_spec a b r), eq (gcd a b) r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "unfold gcd.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b r : nat) (_ : gcd_spec a b r), eq (gcd a b) r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "unfold proj1_sig.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b r : nat) (_ : gcd_spec a b r),\neq (proj1_sig (gcd_ex a b)) r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b r : nat) (_ : gcd_spec a b r),\neq (let (a0, _) := gcd_ex a b in a0) r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eapply gcd_spec_uniq.", "context_before": {"fg_goals": [{"hypotheses": ["H : gcd_spec a b r", "a,b,r : nat"], "goal": "eq (let (a0, _) := gcd_ex a b in a0) r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply gcd_correct.", "context_before": {"fg_goals": [{"hypotheses": ["H : gcd_spec a b r", "a,b,r : nat"], "goal": "gcd_spec ?a ?b (let (a0, _) := gcd_ex a b in a0)"}], "bg_goals": [{"hypotheses": ["H : gcd_spec a b r", "a,b,r : nat"], "goal": "gcd_spec ?a ?b r"}], "shelved_goals": [{"hypotheses": ["H : gcd_spec a b r", "a,b,r : nat"], "goal": "nat"}, {"hypotheses": ["H : gcd_spec a b r", "a,b,r : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : gcd_spec a b r", "a,b,r : nat"], "goal": "gcd_spec a b r"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_def1 : forall x : nat, gcd x x = x.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, eq (gcd x x) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall x : nat, eq (gcd x x) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_is_gcd : forall a b : nat, is_gcd a b (gcd a b).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, is_gcd a b (gcd a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, is_gcd a b (gcd a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma preEuclid :\n forall a b c m : nat,\n divides c (m * a) -> divides c (m * b) -> divides c (m * gcd a b).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c m : nat) (_ : divides c (Init.Nat.mul m a))\n  (_ : divides c (Init.Nat.mul m b)),\ndivides c (Init.Nat.mul m (gcd a b))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b c m : nat) (_ : divides c (Init.Nat.mul m a))\n  (_ : divides c (Init.Nat.mul m b)),\ndivides c (Init.Nat.mul m (gcd a b))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_spec_uniq :\n forall a b r1 r2 : nat, gcd_spec a b r1 -> gcd_spec a b r2 -> r1 = r2.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b r1 r2 : nat) (_ : gcd_spec a b r1) (_ : gcd_spec a b r2),\neq r1 r2"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (a b r1 r2 : nat) (_ : gcd_spec a b r1) (_ : gcd_spec a b r2),\neq r1 r2"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_def2 : forall a b : nat, gcd a b = gcd a (b + a).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, eq (gcd a b) (gcd a (Init.Nat.add b a))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, eq (gcd a b) (gcd a (Init.Nat.add b a))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma gcd_def3 : forall a b : nat, gcd a b = gcd (a + b) b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, eq (gcd a b) (gcd (Init.Nat.add a b) b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall a b : nat, eq (gcd a b) (gcd (Init.Nat.add a b) b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem L_Euclides :\n forall x a b : nat, is_gcd x a 1 -> divides x (a * b) -> divides x b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (x a b : nat) (_ : is_gcd x a (S O))\n  (_ : divides x (Init.Nat.mul a b)), divides x b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (x a b : nat) (_ : is_gcd x a (S O))\n  (_ : divides x (Init.Nat.mul a b)), divides x b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_ref : forall a : nat, congruent a a.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall a : nat, congruent a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall a : nat, congruent a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["n,a : nat"], "goal": "congruent a a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["n,a : nat"], "goal": "eq (Init.Nat.add a (Init.Nat.mul ?u n))\n  (Init.Nat.add a (Init.Nat.mul ?v n))"}], "bg_goals": [], "shelved_goals": [{"hypotheses": ["n,a : nat"], "goal": "nat"}, {"hypotheses": ["n,a : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "Unshelve.", "context_before": {"fg_goals": [{"hypotheses": ["n,a : nat"], "goal": "eq (Init.Nat.add a (Init.Nat.mul ?u n))\n  (Init.Nat.add a (Init.Nat.mul ?v n))"}], "bg_goals": [], "shelved_goals": [{"hypotheses": ["n,a : nat"], "goal": "nat"}, {"hypotheses": ["n,a : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "apply n.", "context_before": {"fg_goals": [{"hypotheses": ["n,a : nat"], "goal": "nat"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_sym : forall a b : nat, congruent a b -> congruent b a.\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : congruent a b), congruent b a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : congruent a b), congruent b a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct H.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a b", "n,a,b : nat"], "goal": "congruent b a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "destruct b.", "context_before": {"fg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add b (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "congruent b a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add O (Init.Nat.mul v n))", "n,a,u,v : nat"], "goal": "congruent O a"}], "bg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "congruent (S b) a"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add O (Init.Nat.mul v n))", "n,a,u,v : nat"], "goal": "eq (Init.Nat.add O (Init.Nat.mul ?u n))\n  (Init.Nat.add a (Init.Nat.mul ?v n))"}], "bg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "congruent (S b) a"}], "shelved_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add O (Init.Nat.mul v n))", "n,a,u,v : nat"], "goal": "nat"}, {"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add O (Init.Nat.mul v n))", "n,a,u,v : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "congruent (S b) a"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "eq (Init.Nat.add (S b) (Init.Nat.mul ?u n))\n  (Init.Nat.add a (Init.Nat.mul ?v n))"}], "bg_goals": [], "shelved_goals": [{"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "nat"}, {"hypotheses": ["H : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "n,a,b,u,v : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem div_power_prime :\n forall p w n : nat, prime p -> divides p (power w n) -> divides p w.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p w n : nat) (_ : prime p) (_ : divides p (power w n)),\ndivides p w"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p w n : nat) (_ : prime p) (_ : divides p (power w n)),\ndivides p w"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_mult_O : forall a b : nat, congruent a 0 -> congruent (a * b) 0.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : congruent a O), congruent (Init.Nat.mul a b) O"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : congruent a O), congruent (Init.Nat.mul a b) O"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma L_Euclides2 :\n forall p a b : nat,\n prime p -> divides p (a * b) -> divides p a \\/ divides p b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p a b : nat) (_ : prime p) (_ : divides p (Init.Nat.mul a b)),\nor (divides p a) (divides p b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p a b : nat) (_ : prime p) (_ : divides p (Init.Nat.mul a b)),\nor (divides p a) (divides p b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_add :\n forall a b c : nat, congruent a b -> congruent (a + c) (b + c).\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b),\ncongruent (Init.Nat.add a c) (Init.Nat.add b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b),\ncongruent (Init.Nat.add a c) (Init.Nat.add b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply cong_plus.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a b", "n,a,b,c : nat"], "goal": "congruent (Init.Nat.add a c) (Init.Nat.add b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a b", "n,a,b,c : nat"], "goal": "congruent a b"}], "bg_goals": [{"hypotheses": ["H : congruent a b", "n,a,b,c : nat"], "goal": "congruent c c"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply cong_ref.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a b", "n,a,b,c : nat"], "goal": "congruent c c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma L_Euclides1 :\n forall p a b : nat,\n prime p -> divides p (a * b) -> ~ divides p a -> divides p b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p a b : nat) (_ : prime p) (_ : divides p (Init.Nat.mul a b))\n  (_ : not (divides p a)), divides p b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": [], "goal": "forall (p a b : nat) (_ : prime p) (_ : divides p (Init.Nat.mul a b))\n  (_ : not (divides p a)), divides p b"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_trans :\n forall a b c : nat, congruent a b -> congruent b c -> congruent a c.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b) (_ : congruent b c),\ncongruent a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b) (_ : congruent b c),\ncongruent a c"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_times :\n forall a b c : nat, congruent a b -> congruent (a * c) (b * c).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b),\ncongruent (Init.Nat.mul a c) (Init.Nat.mul b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b),\ncongruent (Init.Nat.mul a c) (Init.Nat.mul b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_pow :\n forall a b c : nat, congruent a b -> congruent (power a c) (power b c).\n"], {"status": "SUCCESS", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b),\ncongruent (power a c) (power b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "induction b.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c : nat) (_ : congruent a b),\ncongruent (power a c) (power b c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "induction c.", "context_before": {"fg_goals": [{"hypotheses": ["n,a : nat"], "goal": "forall (c : nat) (_ : congruent a O), congruent (power a c) (power O c)"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["n,a : nat"], "goal": "forall _ : congruent a O, congruent (power a O) (power O O)"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}, {"hypotheses": ["IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "forall _ : congruent a O, congruent (power a (S c)) (power O (S c))"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "congruent (power a O) (power O O)"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}, {"hypotheses": ["IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "forall _ : congruent a O, congruent (power a (S c)) (power O (S c))"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "eq (Init.Nat.add (power a O) (Init.Nat.mul ?u n))\n  (Init.Nat.add (power O O) (Init.Nat.mul ?v n))"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "forall _ : congruent a O, congruent (power a (S c)) (power O (S c))"}, {"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [{"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "nat"}, {"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "Unshelve.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "eq (Init.Nat.add (power a O) (Init.Nat.mul ?u n))\n  (Init.Nat.add (power O O) (Init.Nat.mul ?v n))"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "forall _ : congruent a O, congruent (power a (S c)) (power O (S c))"}, {"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [{"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "nat"}, {"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "n,a : nat"], "goal": "nat"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "forall _ : congruent a O, congruent (power a (S c)) (power O (S c))"}, {"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "forall _ : congruent a O, congruent (power a (S c)) (power O (S c))"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "simpl.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "congruent (power a (S c)) (power O (S c))"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply cong_mult_O.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "congruent (Init.Nat.mul a (power a c)) O"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a O", "IHc : forall _ : congruent a O, congruent (power a c) (power O c)", "n,a,c : nat"], "goal": "congruent a O"}], "bg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "induction c.", "context_before": {"fg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall (c : nat) (_ : congruent a (S b)),\ncongruent (power a c) (power (S b) c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b), congruent (power a O) (power (S b) O)"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b),\ncongruent (power a (S c)) (power (S b) (S c))"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "econstructor.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "congruent (power a O) (power (S b) O)"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b),\ncongruent (power a (S c)) (power (S b) (S c))"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "eq (Init.Nat.add (power a O) (Init.Nat.mul ?u n))\n  (Init.Nat.add (power (S b) O) (Init.Nat.mul ?v n))"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b),\ncongruent (power a (S c)) (power (S b) (S c))"}], "shelved_goals": [{"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "nat"}, {"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "Unshelve.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "eq (Init.Nat.add (power a O) (Init.Nat.mul ?u n))\n  (Init.Nat.add (power (S b) O) (Init.Nat.mul ?v n))"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b),\ncongruent (power a (S c)) (power (S b) (S c))"}], "shelved_goals": [{"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "nat"}, {"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "nat"}], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a (S b)", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "nat"}], "bg_goals": [{"hypotheses": ["IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b),\ncongruent (power a (S c)) (power (S b) (S c))"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "intros.", "context_before": {"fg_goals": [{"hypotheses": ["IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "forall _ : congruent a (S b),\ncongruent (power a (S c)) (power (S b) (S c))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "inversion H.", "context_before": {"fg_goals": [{"hypotheses": ["H : congruent a (S b)", "IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "congruent (power a (S c)) (power (S b) (S c))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "apply cong_mult.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : eq b0 (S b)", "H1 : eq a0 a", "H0 : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "a0,b0,u,v : nat", "H : congruent a (S b)", "IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "congruent (power a (S c)) (power (S b) (S c))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : eq b0 (S b)", "H1 : eq a0 a", "H0 : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "a0,b0,u,v : nat", "H : congruent a (S b)", "IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "congruent a (S b)"}], "bg_goals": [{"hypotheses": ["H2 : eq b0 (S b)", "H1 : eq a0 a", "H0 : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "a0,b0,u,v : nat", "H : congruent a (S b)", "IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "congruent\n  ((fix power (x n : nat) {struct n} : nat :=\n      match n with\n      | O => S O\n      | S n' => Init.Nat.mul x (power x n')\n      end) a c)\n  ((fix power (x n : nat) {struct n} : nat :=\n      match n with\n      | O => S O\n      | S n' => Init.Nat.mul x (power x n')\n      end) (S b) c)"}], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "eauto.", "context_before": {"fg_goals": [{"hypotheses": ["H2 : eq b0 (S b)", "H1 : eq a0 a", "H0 : eq (Init.Nat.add a (Init.Nat.mul u n))\n  (Init.Nat.add (S b) (Init.Nat.mul v n))", "a0,b0,u,v : nat", "H : congruent a (S b)", "IHc : forall _ : congruent a (S b), congruent (power a c) (power (S b) c)", "c : nat", "IHb : forall (c : nat) (_ : congruent a b), congruent (power a c) (power b c)", "n,a,b : nat"], "goal": "congruent\n  ((fix power (x n : nat) {struct n} : nat :=\n      match n with\n      | O => S O\n      | S n' => Init.Nat.mul x (power x n')\n      end) a c)\n  ((fix power (x n : nat) {struct n} : nat :=\n      match n with\n      | O => S O\n      | S n' => Init.Nat.mul x (power x n')\n      end) (S b) c)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Qed.", "context_before": {"fg_goals": [], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_plus :\n forall a b c d : nat,\n congruent a b -> congruent c d -> congruent (a + c) (b + d).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c d : nat) (_ : congruent a b) (_ : congruent c d),\ncongruent (Init.Nat.add a c) (Init.Nat.add b d)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c d : nat) (_ : congruent a b) (_ : congruent c d),\ncongruent (Init.Nat.add a c) (Init.Nat.add b d)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem congruent' :\n forall a b : nat, b <= a -> congruent a b -> exists k : nat, a = k * n + b.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : le b a) (_ : congruent a b),\nex (fun k : nat => eq a (Init.Nat.add (Init.Nat.mul k n) b))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : le b a) (_ : congruent a b),\nex (fun k : nat => eq a (Init.Nat.add (Init.Nat.mul k n) b))"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong_mult :\n forall a b c d : nat,\n congruent a b -> congruent c d -> congruent (a * c) (b * d).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c d : nat) (_ : congruent a b) (_ : congruent c d),\ncongruent (Init.Nat.mul a c) (Init.Nat.mul b d)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b c d : nat) (_ : congruent a b) (_ : congruent c d),\ncongruent (Init.Nat.mul a c) (Init.Nat.mul b d)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma divides_cong : forall x : nat, divides n x -> congruent 0 x.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (x : nat) (_ : divides n x), congruent O x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (x : nat) (_ : divides n x), congruent O x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nTheorem cong_divides :\n forall a b : nat, b <= a -> congruent a b -> divides n (a - b).\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : le b a) (_ : congruent a b),\ndivides n (Init.Nat.sub a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (a b : nat) (_ : le b a) (_ : congruent a b),\ndivides n (Init.Nat.sub a b)"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
[["Divides.v", "Divides.", " \nLemma cong1_le : forall x : nat, 1 < n -> congruent x 1 -> 1 <= x.\n"], {"status": "INCOMPLETE", "commands": [{"tactic": "Proof.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (x : nat) (_ : lt (S O) n) (_ : congruent x (S O)), le (S O) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}, {"tactic": "Admitted.", "context_before": {"fg_goals": [{"hypotheses": ["n : nat"], "goal": "forall (x : nat) (_ : lt (S O) n) (_ : congruent x (S O)), le (S O) x"}], "bg_goals": [], "shelved_goals": [], "given_up_goals": []}}]}]
